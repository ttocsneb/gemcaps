# Purpose

The Gemini Server Gateway Interface (GSGI) is meant to be a standard portable interface between the server and the application. The main advantage to this would be to allow high level long lived applications to handle requests through a high performance server without the need to write your own server.

CGI based applications have the inherent disadvantage of having to spin-up a new process for each request.

# Specification

The GSGI Protocol is able to offload transactions from the server to an application using pipes. There are two pipes: One for sending requests to the application, and another to send responses to the server. These two pipes are shared only between the server and application. 

## Initializing the Application

The server will start the application by first creating the pipes, then starting the application process (In C this would be done via 'fork' and 'execve') After the application is started, the server is free to start sending requests to the application.

The server will pass options to the application using environment variables. The two required variables indicate the file descriptors for both pipes:

- PIPE_REQUEST: the file descriptor for the request pipe
- PIPE_RESPONSE: the file descriptor for the response pipe

Because the server and application only have one channel to communicate through, all transactions will be asynchronous. Multiple requests can be sent before getting a single response.

## Sending Messages

All messages sent between through the pipes will follow a format similar to that of the Internet Message Format, all be it, much simpler.

=> https://datatracker.ietf.org/doc/html/rfc5322 Internet Message Format (rfc5333)

A message starts with the STX character (0x02). After is the header which holds key-value pairs separated by a colon. The end of the header is marked by an empty line i.e. two LF characters. Optionally there is a body which is ended by the ETX character (0x03).

Because the message is ended by the ETX character, if a body was to include the character, it can do so by escaping it with another ETX character.

```
  message = STX *( header ) LF [ body ] ETX
  header  = name ":" value LF
  name    = "\w+"
  value   = "[^<LF>]+"
  body    = "([^<ETX>]*(?:<ETX><ETX>)?)*"
  STX     = 0x02
  ETX     = 0x03
```message format

## Requests

There are several fields that may be included in a request message:

- id
- host
- port
- path
- query

### id field

The id of a message will be unique for all requests during the lifetime of the process.

### host field

The host is the host given in the gemini request.

### port field

The port is the port that was given in the gemini request. If the port field is absent, then it can be assumed that the port was 1965.

### path field

The path is the path that was given in the gemini request. If the path field is absent, then it can be assumed that the path is empty.

### query field

The query is the query that was given in the gemini request. If the query field is absent, then it can be assumed that the query is empty.

### body

The body of the request message will contain the client certificate if it was provided by the client. I don't yet know enough to know what kind of data to expect from peer authentication, but I would expect that I should either send the entire certificate to the application, or only its fingerprint.

### request example

```
id: 5
host: foo.bar
path: /

``` GSGI Request

## Response Messages

- id
- code
- meta
- cache

### id field

The id of the transaction. This will match the id of the coresponding request message.

### code field

The response code of the response.

### meta field

The meta field of the response.

### cache field

This is an optional field that the server can choose to ignore. It describes how long the server should hold onto the response (in seconds) before discarding it. If the cache field is not provided, then no cache will be made. A value of 0 indicates an infinite cache time.

### body

The content of the response.

### response example

```
id: 5
code: 20
meta: text/gemini
cache: 300
length: 13

Hello World!

```

### example gemini request/response

This request and response is what the client should see.

```
gemini://foo.bar/
20 text/gemini
Hello World!

```